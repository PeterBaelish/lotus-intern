##### 1、轮转法DMP

​		按照执行指令数将程序执行分成“轮”，每一轮每个线程只允许执行一定数量的指令。一轮执行又可以分为并行阶段和串行阶段，在每一轮开始时，程序首先进入并行阶段。这时只要线程之间的访存不发生冲突，就可以一直执行到该轮结束；一旦检测到线程的访存与其他线程发生冲突，则强制线程暂停执行，等待进入串行阶段解决访存冲突。当所有线程都因为发生访存冲突或者执行完该轮的指令数而暂停时，程序就会进入串行执行阶段。在串行阶段线程根据ID号的顺序依次轮流执行。

​		检测访存冲突的办法：将程序内存以“块”为粒度划分，每块设置一个拥有权标志位，标记当前拥有该内存块的线程。在每一轮的并行执行中，线程只能根据内存块的拥有权标记来访问内存，当线程拥有内存块时，该线程就可以对该内存块进行读写访问，其他线程不能对该内存块进行读写操作；当内存块不被任何线程拥有时（共享态），任何线程可以对该内存块进行读操作，而不能写。内存块的状态在并行阶段不会发生改变，进入串行阶段后，每次只有一个线程对内存进行独占访问，当前执行的线程就可以访问任何内存块，同时根据访存指令修改内存块的状态。当线程写内存块时，内存块变为独占态，并归该线程拥有，以方便后续该线程对于内存块的读写；当线程读内存块时，内存块的状态变为共享 态，以方便其他线程后续对该内存块的读。



##### 2、弱确定性算法

​		弱确定性只保证程序同步语句的执行顺序是具有确定性的。



##### 3、弱化内存一致性CoreDet

​		CoreDet系统使用和DMP同样的方法将程序执行分轮，每一轮执行一定数量的指令。不同的是，在每一轮中每个线程都工作在共享内存的本地副本中。确切的说，当一个线程需要写一块共享内存时，系统首先为该线程创建这个内存块的本地副本，然后将内容写道本地副本中。随后该线程对于这块内存的读写都在本地副本中进行。如果线程只对内存进行读操作就不需要创建本地副本，直接在共享内存中进行。CoreDet在每一轮结束时会将本地副本中的内存修改合并到共享内存中，然后清除本地副本。在这个阶段各个线程按照ID号顺序合并内存修改，因此也可以保证确定性。



##### 4、隔离通信法Dthreads

​		首先将多线程程序的线程全部转换为轻量级进程，这样每个线程就可以拥有独立的页表，从而实现对共享内存不同的访问权限。其次，在线程首次修改共享内存时做Copy-on-Write，为每个线程生成共享内存的本地副本，从而避免直接的访存冲突。这些副本以页面为单位组织，称为Twin-Page。在每次需要将本地内存修改提交到共享时，通过逐字节比较原始Page与Twin-Page就可以获得线程的额内存修改。

​		不同的是，Dthreads每轮的长度不是由执行指令数决定的。Dthreads规定，线程在遇到任何一条同步指令时结束当前轮的执行。这样的劣势是可能造成线程之间在每轮执行中的负载不均衡。例如，如果两个线程在进入下一个同步语句前执行的指令数差别很大，就会造成其中一个线程等待时间过长。



##### 5、全局同步问题

​		全局同步是指由确定性系统插入到程序执行中的一种额外的同步点，他要求所有线程在这个同步点中暂停执行，以方便系统处理不确定性。

​		当线程本身的同步策略 和 确定性系统所引入的全局同步产生冲突时，就可能产生确定性和性能方面的问题。

​		为了消除全局同步，在没有全局同步的情况下，必须能够保证通过程序本身的同步来限制数据竞争。为了限制数据竞争，需要将内存一致性弱化到如下程度：如果两个访存操作之间具有happens-before时序关系，后一个操作就必须能够看到前一个操作对内存的更新。这就是DLRC内存一致性模型。通过这个模型，我们可以阻止所有通过共享内存访问行程的线程间通信，将这些通信全部延迟到线程同步的时候。

​		

---------------

Dthread

DTHREADS intercepts communication using the pthreads API, so programs using ad-hoc synchronization will not work with DTHREADS.